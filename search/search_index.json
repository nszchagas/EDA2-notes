{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Sobre a disciplina","text":"<p>Reposit\u00f3rio dedicado para as notas de aula e trabalhos da disciplina: Estruturas de Dados e Algoritmos 2 da Universidade de Bras\u00edlia.</p>"},{"location":"#plano-de-ensino","title":"Plano de Ensino","text":"<p>Haver\u00e1 tr\u00eas avalia\u00e7\u00f5es:</p> <ul> <li>Prova 1: 09/12 (sexta-feira)</li> <li>Prova 2: 09/01 (segunda-feira)</li> <li>Prova 3: 13/02 (segunda-feira)</li> <li>Prova substitutiva: 17/02 (sexta-feira)</li> </ul>"},{"location":"#media-final","title":"M\u00e9dia final","text":"<p>\\(MF = 0,85 \\cdot M_{AS} + 0,15\\cdot M_{AF} + 0,1 \\cdot T\\)</p> <p>Onde \\(M_{AS}\\) e \\(M_AF\\) s\u00e3o, respectivamente, as m\u00e9dias das avalia\u00e7\u00f5es somativas e formativas e T a nota do trabalho.</p>"},{"location":"#referencias","title":"Refer\u00eancias","text":"<ul> <li>Paulo Feofiloff (IME/USP)</li> <li>Prof. Bruno Ribas</li> </ul>"},{"location":"implementacao/listas_encadeadas/","title":"Implementa\u00e7\u00e3o de Listas Encadeadas - C","text":"<p>Algoritmos de listas encadeadas em C.</p>"},{"location":"implementacao/listas_encadeadas/#estrutura-de-celulano","title":"Estrutura de c\u00e9lula/n\u00f3","text":"<p>N\u00f3s armazenando um dado inteiro e um ponteiro para o pr\u00f3ximo n\u00f3.</p> <pre><code>#include &lt;stdio.h&gt; // Utilizada para opera\u00e7\u00f5es de I/O\n#include &lt;stdlib.h&gt; // Utilizada para manipular ponteiros\ntypedef struct celula\n{\nint dado;\nstruct celula *prox;\n} celula;\n</code></pre>"},{"location":"implementacao/listas_encadeadas/#impressao-de-uma-lista-encadeada","title":"Impress\u00e3o de uma Lista Encadeada","text":"<p>A lista pode ser impressa iterativamente, buscando o n\u00f3 seguinte ao n\u00f3 atual at\u00e9 o final da lista <code>p-&gt;prox == NULL</code> ou recursivamente, considerando que cada peda\u00e7o da lista encadeada \u00e9 uma lista encadeada.</p> <pre><code>void imprime(celula *le)\n{\ncelula *noImpresso;\nnoImpresso = le;\nwhile (noImpresso-&gt;prox != NULL)\n{\nprintf(\"%d -&gt; \", noImpresso-&gt;prox-&gt;dado);\nnoImpresso = noImpresso-&gt;prox;\n}\nprintf(\"NULL\\n\");\n}\nvoid imprime_rec(celula *le)\n{\nif (le-&gt;prox == NULL) // Caso base da recurs\u00e3o: \n// quando a c\u00e9lula passada \u00e9 o \u00faltimo item da lista.\n{\nprintf(\"NULL\\n\");\nreturn;\n}\nelse\nprintf(\"%d -&gt; \", le-&gt;prox-&gt;dado);\nimprime_rec(le-&gt;prox); }\n</code></pre>"},{"location":"implementacao/listas_encadeadas/#busca-na-lista-encadeada","title":"Busca na Lista Encadeada","text":"<p>O algoritmo que retorna o n\u00f3 cujo dado \u00e9 o valor buscado pode ser implementada iterativamente ou recursivamente.</p> <pre><code>celula *busca(celula *le, int x)\n{\ncelula *noAtual = le;\nwhile (noAtual-&gt;prox != NULL)\n{\nif (noAtual-&gt;prox-&gt;dado == x)\nreturn noAtual-&gt;prox;\nnoAtual = noAtual-&gt;prox;\n}\nreturn NULL;\n}\ncelula *busca_rec(celula *le, int x)\n{\nif (le-&gt;prox == NULL)\nreturn NULL;\nelse if (le-&gt;prox-&gt;dado == x)\nreturn le-&gt;prox;\nelse\nreturn busca_rec(le-&gt;prox, x);\n}\n</code></pre>"},{"location":"implementacao/listas_encadeadas/#insercao-na-lista-encadeada","title":"Inser\u00e7\u00e3o na Lista Encadeada","text":"<p>Para inserir no in\u00edcio da lista encadeada, cria-se um novo n\u00f3, com o dado desejado, que apontar\u00e1 para o primeiro elemento da lista. Em seguida, a cabe\u00e7a da lista <code>le</code> deve apontar para o novo n\u00f3 criado.</p> <pre><code>void insere_inicio(celula *le, int x)\n{\ncelula *novoNo;\nnovoNo = malloc(sizeof(celula));\nnovoNo-&gt;dado = x;\nnovoNo-&gt;prox = le-&gt;prox;\nle-&gt;prox = novoNo;\n}\n</code></pre> <p>Para inserir um elemento no n\u00f3 anterior ao que cont\u00e9m um determinado valor, ou no final da lista caso n\u00e3o seja encontrado o valor, deve-se criar um novo n\u00f3, com o valor desejado, e fazer a busca pelo n\u00f3 que cont\u00e9m o valor procurado. A busca pode ser feita mantendo-se o ponteiro do n\u00f3 atual na posi\u00e7\u00e3o anterior ao n\u00f3 cujo dado est\u00e1 sendo avaliado, ao encontrar esse valor, faz-se o novo n\u00f3 apontar para o pr\u00f3ximo n\u00f3 apontado pelo no atual e em seguida o n\u00f3 atual (anterior ao valor procurado) apontar para o novo n\u00f3.</p> <pre><code>void insere_antes(celula *le, int x, int y)\n{\ncelula *noAtual = le;\ncelula *novoNo = malloc(sizeof(celula));\nnovoNo-&gt;dado = x;\nwhile (noAtual-&gt;prox != NULL &amp;&amp; noAtual-&gt;prox-&gt;dado != y)\nnoAtual = noAtual-&gt;prox;\nnovoNo-&gt;prox = noAtual-&gt;prox;\nnoAtual-&gt;prox = novoNo;\n}\n</code></pre>"},{"location":"implementacao/listas_encadeadas/#remocao-de-elementos","title":"Remo\u00e7\u00e3o de elementos","text":"<p>Para remover o elemento seguinte ao n\u00f3 passado como par\u00e2metro, basta fazer o n\u00f3 atual apontar para dois n\u00f3s a frente e em seguida desalocar o n\u00f3 deletado.</p> <pre><code>int remove_depois(celula *p)\n{\nif (p-&gt;prox != NULL)\n{\ncelula *lixo;\nlixo = p-&gt;prox;\np-&gt;prox = p-&gt;prox-&gt;prox;\nfree(lixo); // Desaloca o n\u00f3 deletado.\nreturn 1;\n}\nreturn 0;\n}\n</code></pre> <p>Para remover um determinado n\u00f3 cujo dado seja igual ao passado por par\u00e2metro, faz-se a mescla da busca com a remo\u00e7\u00e3o.</p> <pre><code>void remove_elemento(celula *le, int x)\n{\ncelula *noAtual = le;\nwhile (noAtual-&gt;prox != NULL)\n{\nif (noAtual-&gt;prox-&gt;dado == x)\n{\nremove_depois(noAtual);\nreturn;\n}\nnoAtual = noAtual-&gt;prox;\n}\n}\n</code></pre> <p>Algoritmo para remover todas as ocorr\u00eancias de um dado em uma lista encadeada.</p> <pre><code>void remove_todos_elementos(celula *le, int x)\n{\ncelula *noAtual = le-&gt;prox;\ncelula *prev = le;\nwhile (noAtual != NULL)\n{\nif (noAtual-&gt;dado == x)\n{\nprev-&gt;prox = noAtual-&gt;prox;\nnoAtual = prev-&gt;prox;\n}\nelse\n{\nprev = noAtual;\nnoAtual = noAtual-&gt;prox;\n}\n}\n}\n</code></pre>"},{"location":"ordenacao/mergesort/","title":"MergeSort","text":""},{"location":"ordenacao/mergesort/#intercalacao-de-vetores-ordenados","title":"Intercala\u00e7\u00e3o de vetores ordenados","text":"<p>Dados vetores crescentes <code>v[e...meio-1]</code> e <code>v[meio...d-1]</code>, queremos rearranjar <code>v[e...d-1]</code> em ordem crescente. Para isso, utilizamos o algoritmo representado abaixo. A itera\u00e7\u00e3o inicia com o primeiro elemento de cada subvetor, realiza a compara\u00e7\u00e3o entre eles, e insere o menor elemento entre eles na primeira posi\u00e7\u00e3o do vetor auxiliar. A cada itera\u00e7\u00e3o, incrementa-se o \u00edndice de apenas um dos vetores auxiliares. Quando atinge-se a metade do vetor, percorrendo a primeira metade, ou o final, percorrendo a segunda, encerra-se o la\u00e7o e os elementos que n\u00e3o haviam sido colocados no vetor auxiliar s\u00e3o inseridos. Por fim, desaloca-se da mem\u00f3ria o vetor auxiliar.</p> <pre><code>static void intercala(int *v, int e, int meio, int d)\n{\nint *aux = malloc((d - e + 1) * sizeof(int));\nint i = e;\nint j = meio + 1;\nint k = 0;\nwhile (i &lt;= meio &amp;&amp; j &lt;= d)\n{\nif (v[i] &lt;= v[j])\naux[k++] = v[i++];\nelse\naux[k++] = v[j++];\n}\n// Colocar no auxiliar o que ficar faltando ap\u00f3s a primeira itera\u00e7\u00e3o.\nwhile (i &lt;= meio)\naux[k++] = v[i++];\nwhile (j &lt;= d)\naux[k++] = v[j++];\nfor (int m = 0, i = e; i &lt;= d; m++, i++)\nv[i] = aux[m];\nfree(aux);\n}\n</code></pre> <p>Observa\u00e7\u00e3o:</p> <p>A palavra reservada <code>static</code> indica que a fun\u00e7\u00e3o tem car\u00e1ter auxiliar e n\u00e3o deve ser invocada diretamente. </p>"},{"location":"ordenacao/mergesort/#mergesort_1","title":"MergeSort","text":"<p>O algoritmo mergesort parte da premissa de dividir e conquistar, o vetor \u00e9 dividido em subvetores, a partir do elemento central, iterativamente, cada metade \u00e9 ordenada e intercalada. O algoritmo executa recursivamente at\u00e9 atingir o caso base, onde o elemento da esquerda possui um \u00edndice maior ou igual ao \u00edndice do elemento da direita, ou seja, at\u00e9 o caso em que o subvetor resultante possua tamanho 0 ou 1.</p> <pre><code>void mergesort(int *v, int e, int d)\n{\nif (e &gt;= d)\nreturn;\nint meio = (e + d) / 2;\nmergesort(v, e, meio);\nmergesort(v, meio + 1, d);\nintercala(v, e, meio, d);\n}\n</code></pre> <p>O custo de intercalar \\(n\\) elementos \u00e9 \\(O(n)\\). A \u00e1rvore de recurs\u00e3o possui \\(log\\ n\\) n\u00edveis, em que \\(n\\) \u00e9 a quantidade de elementos do vetor. O custo de intercalar todos os elementos em um n\u00edvel \u00e9 de \\(O(n)\\).</p> <p>O custo do algoritmo mergesort \u00e9: \\(O(n\\cdot log\\ n)\\).</p>"},{"location":"ordenacao/quicksort/","title":"Quicksort","text":"<p>O algoritmo quicksort possui complexidade \\(O(n\\cdot log n)\\) no caso m\u00e9dio e \\(O(n^2)\\) no pior caso, que \u00e9 quando os elementos do vetor est\u00e3o arranjados na ordem inversa \u00e0 desejada.</p> <p>A ideia do algoritmo quicksort \u00e9 particionar um vetor <code>v[l...r]</code> de forma que todos os elementos menores fiquem \u00e0 esquerda do vetor e os maiores \u00e0 direita.</p> <p>A solu\u00e7\u00e3o do problema parte da escolha de um piv\u00f4, digamos c. A ideia \u00e9 que os elementos anteriores \u00e0 c sejam menores que ele, e os posteriores maiores.</p>"},{"location":"ordenacao/quicksort/#separacao","title":"Separa\u00e7\u00e3o","text":"<p>A separa\u00e7\u00e3o dos elementos de um piv\u00f4, em rela\u00e7\u00e3o ao piv\u00f4, pode ser feita a seguinte maneira:</p> <pre><code>int particiona(int *v, int e, int d)\n{\nint pivot = v[d];\nint temp, j = e;\nfor (int i = e; i &lt; d; i++)\n{\nif (v[i] &lt;= pivot)\n{\ntemp = v[j], v[j] = v[i], v[i] = temp;\nj++;\n}\n}\ntemp = v[j], v[j] = v[d], v[d] = temp;\nreturn j;\n}\n</code></pre>"},{"location":"ordenacao/quicksort/#quicksort-basico","title":"Quicksort b\u00e1sico","text":"<p>Partindo da fun\u00e7\u00e3o <code>particiona</code>, podemos implementar o quicksort. A premissa do quicksort \u00e9 dividir um vetor em duas partes, a partir do piv\u00f4, e orden\u00e1-los.</p> <pre><code>void quicksort(int *v, int e, int d)\n{\nif (d &lt;= e)\nreturn;\nint j = particiona(v, e, d); quicksort(v, e, j - 1);\nquicksort(v, j + 1, d);\n}\n</code></pre>"},{"location":"ordenacao/quicksort/#mediana-de-3","title":"Mediana de 3","text":"<p>O algoritmo de quicksort pode ser otimizado pela escolha da mediana entre tr\u00eas valores como o piv\u00f4. Essa escolha evita que o piv\u00f4 seja o maior ou menor valor do vetor. A forma cl\u00e1ssica consiste em tomar a mediana entre os elementos <code>v[l]</code>, <code>v[(l+r)/2]</code> e <code>v[r]</code>. A fun\u00e7\u00e3o abaixo determina o valor da mediana e posiciona-a na posi\u00e7\u00e3o <code>r</code> do vetor.</p> <pre><code>void swap(int *array, int index1, int index2)\n{\nint temp = array[index1];\narray[index1] = array[index2];\narray[index2] = temp;\n}\nvoid median(int *v, int l, int r)\n{\nint m = (r + l) / 2;\nif (v[l] &lt;= v[m] &amp;&amp; v[l] &gt;= v[r] || v[l] &gt;= v[m] &amp;&amp; v[l] &lt;= v[r])\nswap(v, l, r);\nif (v[r] &lt;= v[m] &amp;&amp; v[r] &gt;= v[l] || v[r] &gt;= v[m] &amp;&amp; v[r] &lt;= v[l])\nreturn; // already in right position\nif (v[m] &lt;= v[r] &amp;&amp; v[m] &gt;= v[l] || v[m] &gt;= v[r] &amp;&amp; v[m] &lt;= v[l])\nswap(v, m, r);\n}\n</code></pre> <p>Dessa forma, o algoritmo quicksort pode ser otimizado da seguinte maneira:</p> <pre><code>void quicksort(int *v, int e, int d)\n{\nif (d &lt;= e) return;\n// Posiciona o piv\u00f4 na posi\u00e7\u00e3o d\nmedian(v, e, d); int j = particiona(v, e, d); quicksort(v, e, j - 1);\nquicksort(v, j + 1, d);\n}\n</code></pre>"},{"location":"ordenacao/selecao/","title":"Sele\u00e7\u00e3o","text":""},{"location":"ordenacao/selecao/#overview","title":"Overview","text":"<p>Os algoritmos de inser\u00e7\u00e3o, bolha e sele\u00e7\u00e3o possuem complexidade \\(O(n^2)\\).</p> <ul> <li>Inser\u00e7\u00e3o</li> <li>Bolha</li> <li>Sele\u00e7\u00e3o</li> </ul> <p>Os algoritmos quicksort, mergesort e heapsort possuem complexidade \\(O(n\\cdot log\\ n)\\).</p> <ul> <li>Quicksort</li> <li>Mergesort</li> <li>Heapsort</li> </ul> <p>A ordena\u00e7\u00e3o, utilizando algoritmos linear\u00edtimicos, compensa para uma grande quantidade de buscas (muito mais que n buscas), compensa. Ordenar e buscar tem custo \\(O(n\\cdot log n + log n)\\).</p> <p>Os algoritmos shell, contagem e distribui\u00e7\u00e3o possuem complexidade \\(O(n)\\). Esses tr\u00eas algoritmos partem de alguma premissa em rela\u00e7\u00e3o aos dados a serem ordenados.</p> <ul> <li>Shell</li> <li>Contagem</li> <li>Distribui\u00e7\u00e3o</li> </ul>"},{"location":"ordenacao/selecao/#ordenacao-por-insercao","title":"Ordena\u00e7\u00e3o por inser\u00e7\u00e3o","text":"<p>Dado um vetor <code>v[0...n-1]</code> com n elementos:</p> <p>Ideia: Para cada i de <code>0...n-1</code> insere-se <code>v[i]</code> na posi\u00e7\u00e3o correta do subvetor <code>v[0...i]</code>.</p> <p>Exemplo:</p> <pre><code>    [4, -3, 2, 7, 1]\n1\u00ba Passo: i = 0, n\u00e3o h\u00e1 nenhum elemento em v[0...i];\n2\u00ba Passo: i = 1, como -3 \u00e9 menor que 4, inserimos -3 na posi\u00e7\u00e3o 0.\n    [-3, 4, 2, 7, 1]\n3\u00ba Passo: i = 2, como 2 \u00e9 menor que 4, movemos 4 para frente. Como e \u00e9 maior que -3, essa \u00e9 posi\u00e7\u00e3o final dele.\n    [-3, 2, 4, 7, 1]\n4\u00ba Passo: \n    [-3, 2, 4, 7, 1]\n5\u00ba Passo:\n    [-3, 2, 4, 1, 7]\n    [-3, 2, 1, 4, 7]\n    [-3, 1, 2, 1, 7]\n</code></pre> <p>O pior caso ocorre quando o elemento retirado \u00e9 comparado com todos a esquerda, o que acontece quando o vetor est\u00e1 ordenado no sentido contr\u00e1rio ao desejado. Nesse caso, ser\u00e1 feita a seguinte quantidade de compara\u00e7\u00f5es:</p> <p>\\(1 + 2 + ... + n-1 = \\frac{n\\cdot(a_n+a_1)}{2}=\\frac{(n-1)\\cdot n}{2} \\Rightarrow O(n^2)\\).</p> <p>O melhor caso ocorre quando o elemento retirado \u00e9 maior que o antecessor (vetor em ordem crescente). Nesse caso a complexidade \u00e9 linear. \\(\\Rightarrow O(n)\\).</p> <p>Caso m\u00e9dio: \\(O(n^2)\\)</p>"},{"location":"ordenacao/selecao/#ordenacao-por-selecao","title":"Ordena\u00e7\u00e3o por sele\u00e7\u00e3o","text":"<p>Ideia: Para cada i, de 0 a n-1, selecione o menor elemento do subvetor v[i...n-1] e insira-o em v[i].</p> <p>O custo de encontrar o menor elemento do subvetor tem custo \\(O(n)\\), e o custo da ordena\u00e7\u00e3o por sele\u00e7\u00e3o \u00e9 de \\(O(n^2)\\).</p>"},{"location":"ordenacao/selecao/#estabilidade","title":"Estabilidade","text":"<p>Dizemos que um algoritmo de ordena\u00e7\u00e3o \u00e9 est\u00e1vel se ele conserva a ordem relativa de elementos iguais.</p> <p>O algoritmo de ordena\u00e7\u00e3o por inser\u00e7\u00e3o \u00e9 est\u00e1vel. A demonstra\u00e7\u00e3o pode ser feita por indu\u00e7\u00e3o sobre o tamanho do vetor. J\u00e1 o de sele\u00e7\u00e3o, n\u00e3o \u00e9 est\u00e1vel.</p> <p>Exemplo: considerando o vetor \\([4_a, 2, 4_b, 1]\\), temos que a ordena\u00e7\u00e3o pelo algoritmo da sele\u00e7\u00e3o geraria \\([1, 2, 4_b, 4_a]\\).</p>"},{"location":"resumos/arvore_binaria_busca/","title":"\u00c1rvore Bin\u00e1ria de Busca","text":""},{"location":"resumos/arvore_binaria_busca/#motivacao","title":"Motiva\u00e7\u00e3o","text":"<p>As opera\u00e7\u00f5es de inser\u00e7\u00e3o, remo\u00e7\u00e3o e busca em estruturas de dados costumam ter custos complementares, proveniente de um tradeoff na hora de implementa\u00e7\u00e3o.</p> <p> Opera\u00e7\u00e3o Lista Duplamente Encadeada Vetor N\u00e3o Ordenado Vetor Ordenado \u00c1rvore Bin\u00e1ria de Busca Inser\u00e7\u00e3o e Remo\u00e7\u00e3o \\(O(1)\\) \\(O(1)\\) \\(O(n)\\) \\(O(log\\ n)\\) Busca \\(O(n)\\) \\(O(n)\\) \\(O(n\\cdot log\\ n)\\) \\(O(log\\ n)\\) <p> Tabela 1: Custo das Opera\u00e7\u00f5es. Fonte: [1] </p> <p></p> <p> A inser\u00e7\u00e3o e remo\u00e7\u00e3o em vetores n\u00e3o ordenados pode ter custo \\(O(1)\\) ao inserir sempre no final e remover fazendo a troca com a \u00faltima posi\u00e7\u00e3o.</p> <p>As \u00c1rvores Bin\u00e1rias de Busca, na sua vers\u00e3o mais sofisticada, oferecem opera\u00e7\u00f5es de inser\u00e7\u00e3o, remo\u00e7\u00e3o e busca com custo \\(O(log\\ n)\\).</p>"},{"location":"resumos/arvore_binaria_busca/#definicao","title":"Defini\u00e7\u00e3o","text":"<p>Uma \u00e1rvore bin\u00e1ria tal que cada n\u00f3 \\(r\\) com sub\u00e1rvores esquerda \\(T_e\\) e direita \\(T_d\\) satisfaz:</p> <ul> <li> <p>\\(e&lt;r, \\forall\\ e \\in T_e\\)</p> </li> <li> <p>\\(d&gt;r, \\forall\\ d \\in T_d\\)</p> </li> </ul> <p>\u00e9 uma \u00e1rvore bin\u00e1ria de busca.</p> <p></p> <p> Figura 1: Exemplo de \u00e1rvore bin\u00e1ria de busca. Fonte: [1] </p>"},{"location":"resumos/arvore_binaria_busca/#propriedades","title":"Propriedades","text":"<p>Uma \u00e1rvore bin\u00e1ria de busca satisfaz a seguinte propriedade:</p> <p>A impress\u00e3o dos elementos em um percurso em-ordem (esquerda-raiz-direita) gera uma lista ordenada.</p> <p>No exemplo da Figura 1, o percurso em ordem gera a seguinte sa\u00edda: <code>1, 3, 4, 5, 7, 8, 10, 12, 13, 14</code>.</p> <p>O percurso em ordem \u00e9 feito da seguinte maneira:</p> in_ordem.c<pre><code>// Em ordem visita os n\u00f3s na ordem: esquerda, raiz, direita.\nvoid in_ordem(p_no raiz)\n{\nif (raiz != NULL)\n{\nin_ordem(raiz-&gt;esq);\nprintf(\"%d \", raiz-&gt;dado);\nin_ordem(raiz-&gt;dir);\n}\n}\n</code></pre> <p>A complexidade do algoritmo de percurso em ordem \u00e9 \\(O(n)\\), onde \\(n\\) \u00e9 a quantidade de n\u00f3s de uma \u00e1rvore, uma vez que o fun\u00e7\u00e3o \u00e9 executada \\(2\\cdot n\\) vezes.</p>"},{"location":"resumos/arvore_binaria_busca/#implementacao","title":"Implementa\u00e7\u00e3o","text":"arvore_binaria_de_busca.c<pre><code>typedef struct No\n{\nint chave;\nstruct No *esq, *dir;\n} No;\ntypedef No *p_no;\n// Inicializa\u00e7\u00e3o\np_no criar_arvore();\nvoid destruir_arvore(p_no raiz);\np_no inserir(p_no raiz, int chave);\np_no remover(p_no raiz, int chave);\np_no buscar(p_no raiz, int chave);\np_no buscar_iterativo(p_no raiz, int chave);\np_no minimo(p_no raiz);\np_no maximo(p_no raiz);\np_no sucessor(p_no raiz);\np_no criar_arvore()\n{\np_no raiz = malloc(sizeof(No));\nreturn raiz;\n}\n// A destrui\u00e7\u00e3o tem que ser feita\n// das folhas para cima.\nvoid destruir_arvore(p_no raiz)\n{\nif (raiz != NULL)\n{\nif (raiz-&gt;esq != NULL)\ndestruir_arvore(raiz-&gt;esq);\nif (raiz-&gt;dir != NULL)\ndestruir_arvore(raiz-&gt;dir);\n}\nfree(raiz);\n}\n</code></pre>"},{"location":"resumos/arvore_binaria_busca/#insercao-e-remocao","title":"Inser\u00e7\u00e3o e Remo\u00e7\u00e3o","text":"<p>Antes de fazer a inser\u00e7\u00e3o, devemos determinar onde inserir o valor, fazendo uma busca por ele. Ent\u00e3o, inserimos ele na posi\u00e7\u00e3o ele deveria estar.</p> <p>O algoritmo insere na \u00e1rvore recursivamente e devolve um ponteiro para a raiz da nova \u00e1rvore.</p> insercao_e_remocao.c<pre><code>p_no inserir(p_no raiz, int chave)\n{\nif (raiz == NULL)\n{\nraiz = malloc(sizeof(No));\nraiz-&gt;chave = chave;\nraiz-&gt;esq = raiz-&gt;dir = NULL;\nreturn raiz;\n}\nif (chave &lt; raiz-&gt;chave)\nraiz-&gt;esq = inserir(raiz-&gt;esq, chave);\nelse\nraiz-&gt;dir = inserir(raiz-&gt;dir, chave);\nreturn raiz;\n}\np_no remover_sucessor(p_no raiz)\n{\np_no min = raiz-&gt;dir;\np_no pai = raiz;\nwhile (min-&gt;esq != NULL)\n{\npai = min;\nmin = min-&gt;esq;\n}\nif (pai-&gt;esq == min)\npai-&gt;esq = min-&gt;dir;\nelse\npai-&gt;dir = min-&gt;dir;\nraiz-&gt;chave = min-&gt;chave;\n}\np_no remover(p_no raiz, int chave)\n{\nif (raiz != NULL)\n{\nif (chave &lt; raiz-&gt;chave)\nraiz-&gt;esq = remover(raiz-&gt;esq, chave);\nelse if (chave &gt; raiz-&gt;chave)\nraiz-&gt;dir = remover(raiz-&gt;dir, chave);\nelse if (raiz-&gt;esq == NULL)\nreturn raiz-&gt;dir;\nelse if (raiz-&gt;dir == NULL)\nreturn raiz-&gt;esq;\nelse\nremover_sucessor(raiz);\n}\nreturn raiz;\n}\n</code></pre>"},{"location":"resumos/arvore_binaria_busca/#busca","title":"Busca","text":"<p>A ideia \u00e9 semelhante \u00e0 busca bin\u00e1ria, ou o valor procurado est\u00e1 na raiz da \u00e1rvore, ou \u00e9 menor, ou \u00e9 maior. Se for menor, estar\u00e1 na sub\u00e1rvore da esquerda, se for maior, na da direita.</p> buscar.c<pre><code>p_no buscar(p_no raiz, int chave)\n{\nif (raiz != NULL)\n{\nif (raiz-&gt;chave == chave)\nreturn raiz;\nif (raiz-&gt;chave &gt; chave)\nreturn buscar(raiz-&gt;esq, chave);\nelse\nreturn buscar(raiz-&gt;dir, chave);\n}\nreturn NULL;\n}\np_no buscar_iterativo(p_no raiz, int chave)\n{\nwhile (raiz != NULL &amp;&amp; chave != raiz-&gt;chave)\nif (chave &lt; raiz-&gt;chave)\nraiz = raiz-&gt;esq;\nelse\nraiz = raiz-&gt;dir;\nreturn raiz;\n}\n</code></pre> <p>A complexidade da busca em uma \u00e1rvore de <code>n</code> n\u00edveis, se a \u00e1rvore estiver balanceada, \u00e9 \\(O(log n)\\), e no pior caso a \u00e1rvore assemelha-se \u00e0 uma lista encadeada, o que faz a busca ter complexidade \\(O(n^2)\\). Isso ocorre quando os dados est\u00e3o ordenados, ent\u00e3o um novo n\u00f3 sempre ser\u00e1 inserido do mesmo lado, esquerdo, caso decrescente, direito, quando crescente.</p> <p>No caso m\u00e9dio, a \u00e1rvore tende a ser balanceada, j\u00e1 que cada elemento inserido tem 50% de chance de estar \u00e0 esquerda ou \u00e0 direita da raiz.</p>"},{"location":"resumos/arvore_binaria_busca/#minimo","title":"M\u00ednimo","text":"<p>Basta andar a \u00e1rvore sempre \u00e0 esquerda, at\u00e9 encontrar um n\u00f3 que n\u00e3o tenha filhos a esquerda.</p> minimo.c<pre><code>p_no minimo(p_no raiz)\n{\np_no minimo = raiz;\nwhile (minimo-&gt;esq != NULL)\nminimo = minimo-&gt;esq;\nreturn minimo;\n}\np_no minimo_rec(p_no raiz)\n{\nif (raiz == NULL || raiz-&gt;esq == NULL)\nreturn raiz;\nreturn minimo_rec(raiz-&gt;esq);\n}\n</code></pre>"},{"location":"resumos/arvore_binaria_busca/#maximo","title":"M\u00e1ximo","text":"<p>Basta andar a \u00e1rvore sempre \u00e0 direita, at\u00e9 encontrar um n\u00f3 que n\u00e3o tenha filhos a direita.</p> maximo.c<pre><code>p_no maximo(p_no raiz)\n{\np_no maximo = raiz;\nwhile (maximo-&gt;dir != NULL)\nmaximo = maximo-&gt;dir;\nreturn maximo;\n}\np_no maximo_rec(p_no raiz)\n{\nif (raiz == NULL || raiz-&gt;dir == NULL)\nreturn raiz;\nreturn maximo_rec(raiz-&gt;dir);\n}\n</code></pre>"},{"location":"resumos/arvore_binaria_busca/#sucessor","title":"Sucessor","text":"sucessor.c<pre><code>// Retorna o pr\u00f3ximo n\u00f3 na ordena\u00e7\u00e3o.\np_no sucessor(p_no raiz)\n{\nif (raiz != NULL &amp;&amp; raiz-&gt;dir != NULL)\nreturn minimo(raiz-&gt;dir);\nreturn NULL;\n}\n</code></pre>"},{"location":"resumos/arvore_binaria_busca/#referencias","title":"Refer\u00eancias","text":"<p>[1] \u00c1rvores Bin\u00e1rias de Busca - Notas de aula do professor Rafael C. S. Schouery, dispon\u00edveis no link.</p>"},{"location":"resumos/arvores_binarias/","title":"\u00c1rvores Bin\u00e1rias","text":"<p>Uma \u00e1rvore \u00e9 um conjunto de elementos interligados entre si de forma que um elemento \u00e9 a raiz e os demais se dividem em \\(n\\geq0\\), subconjuntos disjuntos chamados sub\u00e1rvores.</p> <p>Os elementos da \u00e1rvore s\u00e3o chamados de n\u00f3s e as liga\u00e7\u00f5es entre eles s\u00e3o chamadas de arestas. O n\u00f3 que n\u00e3o possui pai \u00e9 dito n\u00f3 raiz e os n\u00f3s sem filhos s\u00e3o ditos folhas. O grau de um n\u00f3 \u00e9 a quantidade de sub\u00e1rvores que se originam dele.</p> <p>Se uma \u00e1rvore for tal que \\(grau(n)\\leq2\\ \\forall\\ n\\ \\in\\ \u00c1rvore\\), ent\u00e3o dizemos que ela \u00e9 uma \u00e1rvore bin\u00e1ria.</p> <p>N\u00edveis s\u00e3o \"gera\u00e7\u00f5es\" de n\u00f3s na \u00e1rvore, e a altura de uma \u00e1rvore \u00e9 o seu maior n\u00edvel. Em uma \u00e1rvore bin\u00e1ria, um n\u00edvel \\(k\\) pode ter no m\u00e1ximo \\(2^k\\) n\u00f3s. O crescimento dos n\u00f3s, conforme aumentamos o n\u00edvel, \u00e9 exponencial.</p> <p>O  m\u00e1ximo de n\u00f3s numa \u00e1rvore de altura \\(h\\) \u00e9: \\(2^0+2^1+...+2^h = 2^{k+1}-1\\), pela soma dos termos da PG de raz\u00e3o 2.</p>"},{"location":"resumos/arvores_binarias/#propriedades","title":"Propriedades","text":"<p>Uma \u00e1rvore de altura \\(h\\) tem no m\u00ednimo \\(h\\) e no m\u00e1ximo \\(2^h-1\\) n\u00f3s.</p> <p> <p>Figura 1: \u00c1rvores de altura 3 com o m\u00ednimo e m\u00e1ximo de n\u00f3s. Fonte: [1]  </p> <p>Se a \u00e1rvore tem \\(n\\geq1\\) n\u00f3s, ent\u00e3o a altura \u00e9 no m\u00ednimo \\(\\lfloor log_2(n+1) \\rfloor\\), quando a \u00e1rvore \u00e9 completa, e no m\u00e1ximo \\(n\\), quando cada n\u00f3 n\u00e3o-terminal tem apenas um filho.</p>"},{"location":"resumos/arvores_binarias/#arvore-binaria-completa","title":"\u00c1rvore Bin\u00e1ria Completa","text":"<p>Uma \u00e1rvore bin\u00e1ria \u00e9 dita completa se todos os n\u00edveis, exceto o \u00faltimo, est\u00e3o cheios e os n\u00f3s do \u00faltimo n\u00edvel est\u00e3o o mais \u00e0 esquerda poss\u00edvel.</p> <p>Uma \u00e1rvore bin\u00e1ria completa com n n\u00f3s tem \\(\\left \\lceil log(n+1) \\right \\rceil = O(log n)\\) n\u00edveis.</p> <p>Podemos representar \u00e1rvores bin\u00e1rias utilizando vetores.</p>"},{"location":"resumos/arvores_binarias/#igualdade","title":"Igualdade","text":"<p>Duas \u00e1rvores s\u00e3o iguais se possu\u00edrem os mesmos dados e mesma estrutura. \u00c1rvores com os mesmos dados, mas estruturas diferentes, s\u00e3o ditas isomorfas.</p>"},{"location":"resumos/arvores_binarias/#implementacao","title":"Implementa\u00e7\u00e3o","text":"<p>A implementa\u00e7\u00e3o pode ser feita por meio de listas encadeadas ou vetores, ambas implementa\u00e7\u00f5es tem vantagens e desvantagens, o uso de listas encadeadas pode diminuir a performance durante a varredura da \u00e1rvore, pois os n\u00f3s n\u00e3o est\u00e3o salvos em posi\u00e7\u00f5es sequenciais da mem\u00f3ria, em contrapartida a inser\u00e7\u00e3o em uma \u00e1rvore na estrutura de vetor \u00e9 mais trabalhosa e pode exigir redimensionamento.</p>"},{"location":"resumos/arvores_binarias/#listas-encadeadas","title":"Listas Encadeadas","text":"<p>Cada n\u00f3 da lista encadeada (Figura 2) possui a estrutura apresentada no trecho de C\u00f3digo 2.</p> <p> <p>Figura 2: Implementa\u00e7\u00e3o de \u00e1rvore utilizando lista encadeada. Fonte: [1]  </p> arvores.c<pre><code>typedef struct No\n{\nint dado;\nstruct No *esq, *dir;\n} No;\ntypedef No *p_no;\ntypedef No *p_fila;\np_no criar_arvore(int dado, p_no esq, p_no dir);\np_no procurar_no(p_no raiz, int valor);\nint numero_nos(p_no raiz);\nint altura(p_no raiz);\n// Percursos\nvoid pre_ordem(p_no raiz);\nvoid pos_ordem(p_no raiz);\nvoid in_ordem(p_no raiz);\nvoid em_largura(p_no raiz);\n</code></pre>"},{"location":"resumos/arvores_binarias/#criar-arvore","title":"Criar \u00e1rvore","text":"<p>A cria\u00e7\u00e3o da \u00e1rvore ser\u00e1 das folhas para a raiz, criando-se a \u00e1rvore esquerda, \u00e1rvore direita e a raiz delas. Nesse caso j\u00e1 sabemos todos os elementos da \u00e1rvore.</p> criar_arvore.c<pre><code>// Cria um n\u00f3 na \u00e1rvore, com dado e filhos esquerdo e direito.\np_no criar_arvore(int dado, p_no esq, p_no dir)\n{\np_no raiz = malloc(sizeof(p_no));\nraiz-&gt;dado = dado;\nraiz-&gt;esq = esq;\nraiz-&gt;dir = dir;\nreturn raiz;\n}\n</code></pre>"},{"location":"resumos/arvores_binarias/#procurar-no","title":"Procurar N\u00f3","text":"procurar_no.c<pre><code>// Escolhe um tipo de varredura e faz a busca.\n// Em ordem: esquerda, raiz, direita\np_no procurar_no(p_no raiz, int valor)\n{\np_no esq;\nif (raiz == NULL || raiz-&gt;dado == valor)\nreturn raiz;\nesq = procurar_no(raiz-&gt;esq, valor);\nif (esq != NULL)\nreturn esq;\nreturn procurar_no(raiz-&gt;dir, valor);\n}\n</code></pre>"},{"location":"resumos/arvores_binarias/#numero-de-nos","title":"N\u00famero de N\u00f3s","text":"numero_nos.c<pre><code>// Faz a contagem do n\u00famero de n\u00f3s dos filhos e acrescenta a raiz.\nint numero_nos(p_no raiz)\n{\nif (raiz == NULL)\nreturn 0;\nreturn numero_nos(raiz-&gt;esq) + numero_nos(raiz-&gt;dir) + 1;\n}\n</code></pre>"},{"location":"resumos/arvores_binarias/#altura","title":"Altura","text":"altura.c<pre><code>int altura(p_no raiz)\n{\nint esq, dir;\nif (raiz == NULL)\nreturn 0;\nesq = altura(raiz-&gt;esq);\ndir = altura(raiz-&gt;dir);\nreturn 1 + (esq &gt; dir ? esq : dir);\n}\n</code></pre>"},{"location":"resumos/arvores_binarias/#vetores","title":"Vetores","text":"<p>A \u00e1rvore \u00e9 distribu\u00edda em um vetor de forma que dada uma raiz na posi\u00e7\u00e3o <code>i</code>, seus filhos esquerdo e direito est\u00e3o nas posi\u00e7\u00f5es <code>2*i+1</code> e <code>2*i+2</code>, respectivamente.</p> <p>Observe que como uma \u00e1rvore bin\u00e1ria de com <code>k</code> n\u00edveis tem, no m\u00e1ximo <code>2^k</code> n\u00f3s, sabendo a altura da \u00e1rvore \u00e9 poss\u00edvel alocar o tamanho certo do vetor.</p> <p> <p>Figura 3: Exemplo de \u00e1rvore (bin\u00e1ria de busca). Fonte: [2]  </p> <p>A \u00e1rvore da Figura 3 ocuparia o vetor <code>v</code> da maneira representada a seguir, onde <code>-1</code> indica posi\u00e7\u00f5es desocupadas do vetor.</p> <pre><code>// Posi\u00e7\u00e3o:       0  1  2  3  4  5  6  7\nv = [ 6, 5, 7, 2, 5,-1, 8,-1]\n</code></pre> <p>As fun\u00e7\u00f5es que calculam as posi\u00e7\u00f5es dos pais e filhos podem ser definidas utilizando macros. O vetor pode ser encapsulado em uma struct contendo tamb\u00e9m o seu tamanho.</p> arvore.c<pre><code>#define item int\ntypedef struct\n{\nitem *content;\nint size;\n} tree;\ntypedef tree *p_tree;\n#define PAI(n) ((int)n / 2)\n#define ESQ(n) (2 * n + 1)\n#define DIR(n) (2 * n + 2)\nvoid criar_arvore(p_tree tree, int height);\nint inserir(p_tree tree, item value, int start);\n</code></pre> <p> A defini\u00e7\u00e3o de <code>item</code> por macro permite a altera\u00e7\u00e3o do tipo em tempo de compila\u00e7\u00e3o, com a flag <code>-D</code>, utilizando o gcc. Esse tipo de implementa\u00e7\u00e3o fornece maior versatilidade no c\u00f3digo.</p> <pre><code>gcc -o  a.out -Ditem=float a.c\n</code></pre>"},{"location":"resumos/arvores_binarias/#criar-arvore_1","title":"Criar \u00e1rvore","text":"criar.c<pre><code>void criar_arvore(p_tree tree, int height)\n{\nint size = pow_2(height);\ntree-&gt;size = size;\ntree-&gt;content = malloc(size * sizeof(item));\nfor (int i = 0; i &lt; tree-&gt;size; i++)\n{\ntree-&gt;content[i] = -1;\n}\n}\n</code></pre>"},{"location":"resumos/arvores_binarias/#inserir-no-abb1","title":"Inserir N\u00f3 (ABB\u00b9)","text":"inserir.c<pre><code>int inserir(p_tree tree, item value, int start)\n{\nfor (int i = start; i &lt; tree-&gt;size; i++)\n{\nif (tree-&gt;content[i] == -1)\n{\ntree-&gt;content[i] = value;\nreturn i;\n}\nif (value &lt; tree-&gt;content[i])\nreturn inserir(tree, value, ESQ(i));\nif (value &gt; tree-&gt;content[i])\nreturn inserir(tree, value, DIR(i));\n}\nreturn -1;\n}\n</code></pre> <p>\u00b9\u00c1rvore Bin\u00e1ria de Busca</p>"},{"location":"resumos/arvores_binarias/#varredura","title":"Varredura","text":"<p>\u00c1rvores s\u00e3o estruturas de dados n\u00e3o lineares, pois h\u00e1 v\u00e1rias formas distintas de percorrer seus elementos. As tr\u00eas formas padr\u00e3o s\u00e3o:</p> <ul> <li>Em ordem (esquerda-raiz-direita)</li> <li>Pr\u00e9-ordem (raiz-esquerda-direita)</li> <li>P\u00f3s-ordem (esquerda-direita-raiz)</li> </ul>"},{"location":"resumos/arvores_binarias/#pos-ordem","title":"P\u00f3s ordem","text":"<p>O algoritmo para a varredura p\u00f3s ordem visita:</p> <ol> <li>A sub\u00e1rvore esquerda da raiz, em ordem e-d-r</li> <li>A sub\u00e1rvore direita da raiz, em ordem e-d-r</li> <li>A raiz</li> </ol> <p> <p>Figura 4: Ordem de visita\u00e7\u00e3o dos n\u00f3s em p\u00f3s-ordem. Fonte: [1] </p> posordem.c<pre><code>// P\u00f3s ordem visita os n\u00f3s na ordem: esquerda, direita, raiz.\nvoid pos_ordem(p_no raiz)\n{\nif (raiz != NULL)\n{\npos_ordem(raiz-&gt;esq);\npos_ordem(raiz-&gt;dir);\nprintf(\"%d \", raiz-&gt;dado);\n}\n}\n</code></pre>"},{"location":"resumos/arvores_binarias/#pre-ordem","title":"Pr\u00e9 ordem","text":"<p>O algoritmo para a varredura pr\u00e9 ordem visita:</p> <ol> <li>A raiz</li> <li>A sub\u00e1rvore esquerda da raiz, em ordem r-e-d</li> <li>A sub\u00e1rvore direita da raiz, em ordem r-e-d</li> </ol> <p> <p>Figura 5: Ordem de visita\u00e7\u00e3o dos n\u00f3s em pr\u00e9-ordem. Fonte: [1] </p> preordem.c<pre><code>// Pr\u00e9 ordem visita os n\u00f3s na ordem: raiz, esquerda, direita.\nvoid pre_ordem(p_no raiz)\n{\nif (raiz != NULL)\n{\nprintf(\"%d \", raiz-&gt;dado);\npre_ordem(raiz-&gt;esq);\npre_ordem(raiz-&gt;dir);\n}\n}\n</code></pre>"},{"location":"resumos/arvores_binarias/#em-ordem","title":"Em ordem","text":"<p>O algoritmo para a varredura em ordem visita:</p> <ol> <li>A sub\u00e1rvore esquerda da raiz, em ordem e-r-d</li> <li>A raiz</li> <li>A sub\u00e1rvore direita da raiz, em ordem e-r-d</li> </ol> <p> <p>Figura 6: Ordem de visita\u00e7\u00e3o dos n\u00f3s em ordem. Fonte: [1] </p> em_ordem.c<pre><code>// Em ordem visita os n\u00f3s na ordem: esquerda, raiz, direita.\nvoid in_ordem(p_no raiz)\n{\nif (raiz != NULL)\n{\nin_ordem(raiz-&gt;esq);\nprintf(\"%d \", raiz-&gt;dado);\nin_ordem(raiz-&gt;dir);\n}\n}\n</code></pre>"},{"location":"resumos/arvores_binarias/#em-largura","title":"Em largura","text":"<p>O percurso em largura visita os n\u00f3s por n\u00edveis, da esquerda para a direita.  <p>Figura 7: Percurso em Largura. Fonte: [1] </p> em_largura.c<pre><code>// Em largura visita os n\u00f3s, por n\u00edvel, da esquerda pra direita.\nvoid em_largura(p_no raiz)\n{\np_fila f;\nf = criar_fila();\nenfileirar(f, raiz);\nwhile (!fila_vazia(f))\n{\nraiz = desenfileirar(f);\nif (raiz != NULL)\n{\nenfileirar(f, raiz-&gt;esq);\nenfileirar(f, raiz-&gt;dir);\nprintf(\"%d \", raiz-&gt;dado); /*visita raiz*/\n}\n}\ndestruir_fila(f);\n}\n</code></pre>"},{"location":"resumos/arvores_binarias/#referencias","title":"Refer\u00eancias","text":"<p>[1] \u00c1rvores Bin\u00e1rias - Notas de aula do professor Rafael C. S. Schouery, dispon\u00edveis no link.</p> <p>[2] Introduction to Algorithms, 3rd edition.</p>"},{"location":"resumos/fila_de_prioridade/","title":"Fila de Prioridade e Heap","text":"<p>Uma fila de prioridade \u00e9 uma estrutura de dados com duas opera\u00e7\u00f5es b\u00e1sicas:</p> <ul> <li>Inserir um novo elemento</li> <li>Remover o elemento com maior chave (prioridade)</li> </ul> <p> Pilhas e filas assemelham-se \u00e0s filas de prioridade, na primeira o elemento de maior prioridade \u00e9 o \u00faltimo inserido, e nas filas o contr\u00e1rio acontece.</p>"},{"location":"resumos/fila_de_prioridade/#implementacao","title":"Implementa\u00e7\u00e3o","text":"header.c<pre><code>typedef struct\n{\nchar nome[20];\nint chave;\n} Item;\ntypedef struct\n{\nItem *v;\nint n, tamanho;\n} FP;\ntypedef FP *p_fp;\np_fp criar(int tam);\nvoid inserir(p_fp fila, Item item);\nItem extrair_maximo(p_fp fila);\nint vazia(p_fp fila);\nint cheia(p_fp fila);\nvoid troca(Item *a, Item *b)\n{\nItem t = *a;\n*a = *b;\n*b = t;\n}\n</code></pre> <p>A troca de elementos ser\u00e1 frequente, ent\u00e3o para facilitar a leitura do c\u00f3digo, foi implementada a fun\u00e7\u00e3o troca.</p>"},{"location":"resumos/fila_de_prioridade/#criacao-da-fila-prioridade","title":"Cria\u00e7\u00e3o da fila prioridade","text":"<p>A cria\u00e7\u00e3o da fila de prioridade consiste basicamente em alocar mem\u00f3ria para as estruturas e definir o tamanho com e quantidade de valores preenchidos.</p> criar.c<pre><code>p_fp criar(int tam)\n{\np_fp fila = malloc(sizeof(FP));\nfila-&gt;tamanho = tam;\nfila-&gt;v = malloc(sizeof(Item) * tam);\nfila-&gt;n = 0;\nreturn fila;\n}\n</code></pre>"},{"location":"resumos/fila_de_prioridade/#insercao","title":"Inser\u00e7\u00e3o","text":"<p>A inser\u00e7\u00e3o \u00e9 simples e feita no final do vetor.</p> inserir.c<pre><code>void inserir(p_fp fila, Item item)\n{\nfila-&gt;v[fila-&gt;n++] = item;\n}\n</code></pre> <p> A complexidade do algoritmo \u00e9 \\(O(1)\\).</p>"},{"location":"resumos/fila_de_prioridade/#remocao-do-maximo","title":"Remo\u00e7\u00e3o do m\u00e1ximo","text":"<p>O algoritmo percorre o vetor, guardando o \u00edndice do maior valor encontrado at\u00e9 o momento. No final, \u00e9 feita a troca do \u00faltimo elemento do vetor <code>fprio-&gt;v[fprio-&gt;n-1]</code> com o maior valor encontrado <code>fprio-&gt;v[max]</code>. Ent\u00e3o, o valor de <code>n</code> \u00e9 decrementado, pois um item foi removido, e o valor removido \u00e9 retornado.</p> extrair_maximo.c<pre><code>Item extrair_maximo(p_fp fila)\n{\nint index = 0;\nfor (int i = 0; i &lt; fila-&gt;n; i++)\nif (fila-&gt;v[i].chave &gt; fila-&gt;v[index].chave)\nindex = i;\ntroca(&amp;fila-&gt;v[index], &amp;fila-&gt;v[fila-&gt;n - 1]);\nfila-&gt;n--;\nreturn fila-&gt;v[fila-&gt;n];\n}\n</code></pre> <p> A complexidade da extra\u00e7\u00e3o do m\u00e1ximo \u00e9 \\(O(n)\\).</p> <p>Os custos das opera\u00e7\u00f5es inser\u00e7\u00e3o e extra\u00e7\u00e3o s\u00e3o invertidas caso se deseje manter o vetor ordenado.</p>"},{"location":"resumos/fila_de_prioridade/#cheia-vs-vazia","title":"Cheia vs Vazia","text":"<p>Para verificar se a fila est\u00e1 cheia, ou vazia, podemos usar as fun\u00e7\u00f5es a seguir.</p> vazia.c<pre><code>int vazia(p_fp fila)\n{\nreturn fila-&gt;n == 0;\n}\n</code></pre> cheia.c<pre><code>int cheia(p_fp fila)\n{\nreturn fila-&gt;tamanho - fila-&gt;n == 0;\n}\n</code></pre>"},{"location":"resumos/fila_de_prioridade/#heap","title":"Heap","text":""},{"location":"resumos/fila_de_prioridade/#definicao","title":"Defini\u00e7\u00e3o","text":"<p>O heap de m\u00e1ximo \u00e9 uma \u00e1rvore em que os filhos de cada n\u00f3 s\u00e3o menores ou iguais ao pai. Simetricamente, no heap de m\u00ednimo os filhos s\u00e3o maiores ou iguais ao pai. Essa estrutura possui a propriedade de alocar o maior (ou menor) elemento na raiz da \u00e1rvore.</p> <p>Um heap n\u00e3o \u00e9 uma \u00e1rvore bin\u00e1ria de busca, nele os dados est\u00e3o bem menos estruturados, pois o interesse est\u00e1 apenas em encontrar o maior (ou menor) valor.</p> <p> <p>Figura 1: Heap de M\u00e1ximo. Fonte: [1] </p>"},{"location":"resumos/fila_de_prioridade/#implementacao_1","title":"Implementa\u00e7\u00e3o","text":"<p>O Heap pode ser representado na forma de arvore bin\u00e1ria completa, utilizando vetores.</p> heap.c<pre><code>void insere_no_heap(p_fp fila, Item item);\nItem get_maximo_heap(p_fp fila);\nvoid altera_prioridade(p_fp fila, int posicao, int novo_valor);\n// Opera\u00e7\u00f5es\nvoid sobe_no_heap(p_fp fila, int k);\nvoid desce_no_heap(p_fp fila, int k);\n#define PAI(i) ((i - 1) / 2)\n#define F_ESQ(i) (2 * i + 1)\n#define F_DIR(i) (2 * i + 2)\n</code></pre>"},{"location":"resumos/fila_de_prioridade/#subindo-e-descendo-no-heap","title":"Subindo e Descendo no Heap","text":"sobenoheap.c<pre><code>// Sobe um elemento das folhas em dire\u00e7\u00e3o a raiz, de forma que\n//       os filhos de um n\u00f3 sejam sempre menores que ele.\nvoid sobe_no_heap(p_fp fila, int k)\n{\nif (k &gt; 0 &amp;&amp; fila-&gt;v[k].chave &gt; fila-&gt;v[PAI(k)].chave)\n{\ntroca(&amp;fila-&gt;v[k], &amp;fila-&gt;v[PAI(k)]);\nsobe_no_heap(fila, PAI(k));\n}\n}\n</code></pre> descenoheap.c<pre><code>void desce_no_heap(p_fp fila, int k)\n{\nif (k &lt; 0 || F_ESQ(k) &gt;= fila-&gt;n || F_DIR(k) &gt;= fila-&gt;n)\nreturn;\nItem f_esq, f_dir;\nint maior_filho;\nf_esq = fila-&gt;v[F_ESQ(k)];\nf_dir = fila-&gt;v[F_DIR(k)];\nif (fila-&gt;v[k].chave &gt;= f_esq.chave &amp;&amp; fila-&gt;v[k].chave &gt;= f_dir.chave)\nreturn;\nelse\n{\nmaior_filho = (f_esq.chave &gt;= f_dir.chave) ? F_ESQ(k) : F_DIR(k);\ntroca(&amp;fila-&gt;v[k], &amp;fila-&gt;v[maior_filho]);\ndesce_no_heap(fila, maior_filho);\n}\n}\n</code></pre>"},{"location":"resumos/fila_de_prioridade/#insercao_1","title":"Inser\u00e7\u00e3o","text":"heap.c<pre><code>void insere_no_heap(p_fp fila, Item item)\n{\nif (fila-&gt;n &lt;= fila-&gt;tamanho)\n{\nfila-&gt;v[fila-&gt;n++] = item;\nsobe_no_heap(fila, fila-&gt;n - 1);\n}\n}\n</code></pre> <p>A inser\u00e7\u00e3o custa \\(O(log\\ n)\\), pois subimos no m\u00e1ximo at\u00e9 a raiz.</p>"},{"location":"resumos/fila_de_prioridade/#extraindo-o-maximo","title":"Extraindo o m\u00e1ximo","text":"getmaximoheap.c<pre><code>// Trocamos o maior elemento v[0] com o \u00faltimo inserido[n-1] e ajustamos o heap.\nItem get_maximo_heap(p_fp fila)\n{\nItem max = fila-&gt;v[0];\ntroca(&amp;fila-&gt;v[0], &amp;fila-&gt;v[fila-&gt;n - 1]);\nfila-&gt;n--;\ndesce_no_heap(fila, 0);\nreturn max;\n}\n</code></pre> <p>Extrair o valor m\u00e1ximo custa \\(O(log\\ n)\\), pois descemos no m\u00e1ximo a altura da \u00e1rvore.</p>"},{"location":"resumos/fila_de_prioridade/#mudando-a-prioridade","title":"Mudando a prioridade","text":"<p>Se a prioridade do item aumentar, precisamos subir arrumando, caso contr\u00e1rio, descer arrumando.</p> alteraprioridade.c<pre><code>void altera_prioridade(p_fp fila, int posicao, int novovalor)\n{\nint old_prior = fila-&gt;v[posicao].chave;\nfila-&gt;v[posicao].chave = novovalor;\nif (novovalor &gt;= old_prior)\nsobe_no_heap(fila, posicao);\nelse\ndesce_no_heap(fila, posicao);\n}\n</code></pre> <p>Para alterar a prioridade precisamos saber a posi\u00e7\u00e3o do item no heap, e a busca por essa posi\u00e7\u00e3o tem custo  \\(O(n)\\). Podemos melhorar esse custo incluindo um campo <code>id</code> com valores de <code>0</code> a <code>n-1</code> nos itens, criando um vetor de <code>n</code> posi\u00e7\u00f5es como parte do <code>heap</code> armazenando a posi\u00e7\u00e3o de cada item no <code>heap</code>, ent\u00e3o podemos recuperar essa posi\u00e7\u00e3o em \\(O(1)\\).</p>"},{"location":"resumos/fila_de_prioridade/#referencias","title":"Refer\u00eancias","text":"<p>[1] Fila de Prioridade e Heap - Notas de aula do professor Rafael C. S. Schouery, dispon\u00edveis no link.</p>"},{"location":"resumos/hash/","title":"Tabela hash","text":"<p>A tabela hash, ou tabela de dispers\u00e3o, \u00e9 uma estrutura de dados respons\u00e1vel por acelerar muitos algoritmos que envolvem consultas, inser\u00e7\u00f5es e dele\u00e7\u00f5es em tabelas de dados.</p>"},{"location":"resumos/hash/#problema-de-contagem","title":"Problema de contagem","text":"<p>Suponha o seguinte problema de contagem:</p> <p>Um fluxo de n\u00fameros inteiros positivos na entrada <code>stdin</code></p>"},{"location":"resumos/listas_encadeadas/","title":"EDA2 - Aula 2 - Listas Encadeadas","text":""},{"location":"resumos/listas_encadeadas/#notacao-on","title":"Nota\u00e7\u00e3o O(n)","text":""},{"location":"resumos/listas_encadeadas/#definicao","title":"Defini\u00e7\u00e3o","text":"<p>Dizemos que um algoritmo consome tempo $ O(f(n)) $, onde f \u00e9 uma fun\u00e7\u00e3o e n \u00e9 algo que caracteriza a entrada, significa dizer que o algoritmo consome, no m\u00e1ximo, $ c \\cdot f (n)$ opera\u00e7\u00f5es, para quaisquer $ n\\geq n_0 $, onde $ c&gt;0 $ e $ n_0 \\geq 0$.</p>"},{"location":"resumos/listas_encadeadas/#funcoes-classicas-consideradas","title":"Fun\u00e7\u00f5es cl\u00e1ssicas consideradas","text":"<ul> <li>Quantidade constante de opera\u00e7\u00f5es: \\(f(n) = 1 \\rightarrow O(1)\\)</li> <li>Logar\u00edtmico: \\(f(n) = log\\ n\\)</li> <li>Linear: \\(f(n) = n\\)</li> <li>Linear\u00edtmico / quase linear: \\(f(n) = n \\cdot log\\ n\\)</li> <li>Polinomial: $ f(n)=n^k,\\ k\\geq2 $</li> <li>Exponenciais:</li> <li>\\(f(n)=k^n , k \\geq 2\\)</li> <li>\\(f(n)=n^n, n!\\)</li> </ul> <p>Exemplo:</p> <p>A fun\u00e7\u00e3o abaixo retorna o maior elemento do vetor v de tamanho n.</p> <pre><code>int maior(int v[], int n){ // A passagem do vetor v tamb\u00e9m poderia ser feita como int *v. \nint maior = v[0];\nfor (int i = 0; i &lt; n ; i++)\nif (v[i]&gt;maior)\nmaior = v[i];\nreturn maior;\n}\n</code></pre> <p>Para analisar a complexidade de um algoritmo fazemos a contagem de quantas opera\u00e7\u00f5es o algoritmo faz em cada linha.</p> <pre><code>int maior(int v[], int n){\nint maior = v[0]; // Uma opera\u00e7\u00e3o\nfor (int i = 0; i &lt; n ; i++) // S\u00e3o feitas 2n-1 opera\u00e7\u00f5es.\nif (v[i]&gt;maior) // n-1 itera\u00e7\u00f5es do for.\nmaior = v[i]; // Algo &lt;= a n-1\nreturn maior; }\n</code></pre> <p>Ao todo, o algoritmo tem complexidade: \\(O(n)\\).</p>"},{"location":"resumos/listas_encadeadas/#listas-encadeadas","title":"Listas Encadeadas","text":"<p>S\u00e3o utilizadas para armazenar uma cole\u00e7\u00e3o de elementos. \u00c9 uma alternativa aos vetores.</p> <p>Comparativos entre listas e vetores</p> Listas encadeadas Vetores N\u00e3o precisa de espa\u00e7o cont\u00edguo na mem\u00f3ria Requer um espa\u00e7o cont\u00edguo na mem\u00f3ria Acesso: O(n) Acesso: O(1) Inser\u00e7\u00e3o de novo elemento: O(1) Inser\u00e7\u00e3o: O(n) <p>Trade off: O uso de listas encadeadas facilita a inser\u00e7\u00e3o de novos elementos, mas dificulta o acesso.</p>"},{"location":"resumos/listas_encadeadas/#implementacao-de-listas-encadeadas","title":"Implementa\u00e7\u00e3o de listas encadeadas","text":"<p>A lista ser\u00e1 composta pelo encadeamento de n\u00f3s (ou c\u00e9lulas), compostas por um dado e um apontador para o pr\u00f3ximo n\u00f3. Todos os elementos devem ser do mesmo tipo.</p> <p></p> <pre><code>    typedef struct no {\nint dado;\nstruct no *proximo;\n} no;\n</code></pre> <ul> <li>Dado uma c\u00e9lula <code>no</code>, acessamos o valor do seu conte\u00fado com <code>no.dado</code>.</li> <li>Se <code>p</code> \u00e9 o endere\u00e7o de um n\u00f3, acessamos o conte\u00fado deste n\u00f3 por <code>p-&gt;dado</code> e o endere\u00e7o do pr\u00f3ximo n\u00f3 por <code>p-&gt;proximo</code>.  </li> <li>Se <code>p</code> \u00e9 o endere\u00e7o do \u00faltimo n\u00f3 da lista, ent\u00e3o <code>p-&gt;proximo==NULL</code>.</li> <li>Essa estrutura de dados tamb\u00e9m pode ser chamada de lista simplesmente encadeada.</li> <li>A principal varia\u00e7\u00e3o da lista encadeada \u00e9 a lista duplamente encadeada, em que cada n\u00f3 h\u00e1 dois apontadores: para o n\u00f3 anterior e para o n\u00f3 seguinte.</li> <li>Na lista vazia o elemento head (cabe\u00e7a) aponta para NULL ou aponta para si mesmo (lista circular).</li> </ul>"},{"location":"resumos/listas_encadeadas/#endereco-de-uma-lista-encadeada","title":"Endere\u00e7o de uma lista encadeada","text":"<p>O endere\u00e7o de uma lista encadeada (le) \u00e9 o endere\u00e7o de seu primeiro n\u00f3.</p> <ul> <li>Observe que listas s\u00e3o entidades recursivas, se <code>le</code> \u00e9 uma lista encadeada, ent\u00e3o <code>le-&gt;prox</code> tamb\u00e9m \u00e9.</li> </ul> <pre><code>    int main(){\n// Cria\u00e7\u00e3o da lista:\nno *le = malloc(sizeof(no)); le-&gt;proximo = NULL; // Ou le-&gt;proximo = le; (lista circular)\n}\n</code></pre>"},{"location":"resumos/listas_encadeadas/#insercao-em-uma-lista-encadeada","title":"Inser\u00e7\u00e3o em uma lista encadeada","text":"<ol> <li>Alocar o novo n\u00f3.</li> <li>O novo n\u00f3 deve apontar para o sucessor.</li> <li>O antecessor do novo n\u00f3 deve apontar para ele.</li> </ol> <pre><code>void insere(no *p, int valor)\n{\nno *novo = malloc(sizeof(no));\nnovo-&gt;dado = valor;\nnovo-&gt;proximo = p-&gt;proximo;\np-&gt;proximo = novo;\n}\n</code></pre>"},{"location":"resumos/listas_encadeadas/#remocao-em-uma-lista-encadeada","title":"Remo\u00e7\u00e3o em uma lista encadeada","text":"<p>Apontamos para o n\u00f3 anterior ao elemento que ser\u00e1 removido e retorna o valor que foi removido.</p> <pre><code>int removeNo(no *p)\n{\nno *lixo = p-&gt;proximo;\nif (lixo != NULL)\n{\np-&gt;proximo = lixo-&gt;proximo;\nlixo-&gt;dado;\nfree(lixo);\nreturn 0;\n}\nreturn -1;\n}\n</code></pre>"},{"location":"resumos/listas_encadeadas/#imprimindo-uma-lista-usando-recursao","title":"Imprimindo uma lista usando recurs\u00e3o","text":"<pre><code>void printList(no *le)\n{\nno *p;\nprintf(\"[ \");\nfor (p = le-&gt;proximo; p != NULL; p = p-&gt;proximo)\nprintf(\"%d \", p-&gt;dado);\nprintf(\"]\\n\");\n}\n</code></pre>"},{"location":"resumos/listas_encadeadas/#referencia","title":"Refer\u00eancia","text":"<p>[1] Material sobre Listas Encadeadas, do Professor Paulo Feofiloff, dispon\u00edvel no link.</p>"},{"location":"resumos/ponteiros/","title":"Endere\u00e7os e Ponteiros","text":""},{"location":"resumos/ponteiros/#enderecos","title":"Endere\u00e7os","text":"<p>A mem\u00f3ria RAM de qualquer computador \u00e9 uma sequ\u00eancia de bytes. A posi\u00e7\u00e3o (0, 1, 2, ...) que um byte ocupa nessa sequ\u00eancia \u00e9 o seu endere\u00e7o. Cada tipo de dado ocupa um determinado espa\u00e7o na mem\u00f3ria, dados do tipo <code>char</code> ocupam 1 byte, enquanto inteiros (<code>int</code>) ocupam 4. Um n\u00famero decimal de precis\u00e3o dupla (<code>double</code>) ocupa, geralmente, 8 bytes. O n\u00famero exatos de bytes ocupados por um tipo \u00e9 dado pelo operador <code>sizeof</code> em c.</p> <pre><code>struct\n{\nint x, y, z;\n} ponto;\nint main()\n{\nprintf(\"Size of ponto: %ld\\n\", sizeof(ponto));\n// Imprime 12, j\u00e1 que h\u00e1 3*4 bytes.\nreturn 0;\n}\n</code></pre> <p>O endere\u00e7o de uma vari\u00e1vel, em C, pode ser obtido pelo operador <code>&amp;</code>. Para fazer a impress\u00e3o de um endere\u00e7o na console, \u00e9 necess\u00e1rio fazer um casting:</p> <pre><code>    int i = 1234;\nprintf(\" i = %d\\n\", i);             // i = 1234\nprintf(\"&amp;i = %ld\\n\", (long int)&amp;i); // &amp;i = 140732356398116\nprintf(\"&amp;i = %p\\n\", (void *)&amp;i);    // &amp;i = 0x7ffece1c8c24\n</code></pre>"},{"location":"resumos/ponteiros/#ponteiros","title":"Ponteiros","text":"<p>Um ponteiro \u00e9 um tipo especial de vari\u00e1vel que armazena um endere\u00e7o de mem\u00f3ria. Um ponteiro pode ter o endere\u00e7o <code>NULL</code>, que indica um endere\u00e7o inv\u00e1lido.</p> <p> A macro <code>NULL</code> est\u00e1 definida na interface <code>stdlib.h</code> e seu valor \u00e9 zero na maioria dos computadores, \u00e9 armazenada em uma posi\u00e7\u00e3o pr\u00e9-fixada.</p> <p>Dado um ponteiro p, armazenando o endere\u00e7o de i, dizemos que p \u00e9 uma refer\u00eancia \u00e0 vari\u00e1vel, e tem-se que <code>*p == i</code> e <code>&amp;i == p</code>.</p> <p> A exist\u00eancia de ponteiros possibiliza que sejam realizadas opera\u00e7\u00f5es entre eles.</p> <p>H\u00e1 v\u00e1rios tipos de ponteiros, como ponteiros para bytes, para inteiros, para ponteiros para inteiros, etc. Esses ponteiros podem ser declarados da seguinte forma:</p> <pre><code>    int *p1; // Ponteiro para inteiro.\nint **p2; // Ponteiro de ponteiro que aponta para inteiro.\nfloat *p3; // Ponteiro para float.\n</code></pre> <p>A rela\u00e7\u00e3o entre ponteiros e endere\u00e7os pode ser observada no exemplo a seguir.</p> <pre><code>    int i; int *p;\ni = 1234; p = &amp;i;\nprintf(\"*p = %d\\n\", *p);                // Imprime o valor de i.\n// Output: *p = 1234\nprintf(\"&amp;i = p = %ld\\n\", (long int)p);  // Imprime o endere\u00e7o de i.\n// &amp;i = p = 140723065261676\nprintf(\"&amp;i = p = %p\\n\", (void *)p);     // Imprime o endere\u00e7o (hex) de i.\n// &amp;i = p = 0x7ffca4510e6c\nprintf(\"&amp;p = %p\\n\", (void *)&amp;p);        // Imprime o endere\u00e7o do ponteiro p.\n// &amp;p = 0x7ffca4510e70\n</code></pre>"},{"location":"resumos/ponteiros/#aplicacoes","title":"Aplica\u00e7\u00f5es","text":"<pre><code>void troca(int *i, int *j)\n{\nint temp = *i; // Vari\u00e1vel tempor\u00e1ria recebe o valor apontado por i.\n*i = *j; // Endere\u00e7o apontado por i recebe o valor apontado por j.\n*j = temp; // Endere\u00e7o apontado por j recebe o valor temp.\n}\n</code></pre>"},{"location":"resumos/ponteiros/#exercicios","title":"Exerc\u00edcios","text":"<ol> <li> <p>Um ponteiro pode ser usado para dizer a uma fun\u00e7\u00e3o onde ela deve depositar o resultado de seus c\u00e1lculos. Escreva uma fun\u00e7\u00e3o hm que converta minutos em horas-e-minutos. A fun\u00e7\u00e3o recebe um inteiro mnts e os endere\u00e7os de duas vari\u00e1veis inteiras, digamos h e\u00a0m, e atribui valores a essas vari\u00e1veis de modo que m seja menor que 60 e que 60*h + m seja igual a mnts. Escreva tamb\u00e9m uma fun\u00e7\u00e3o main que use a fun\u00e7\u00e3o\u00a0hm.</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\nvoid hm(int minutos, int *h, int*m)\n{\n*h = minutos / 60;\n*m = minutos - *h * 60;\n}\nint main(void)\n{\nint minutos = 210;\nint h, m;\nhm(210, &amp;h, &amp;m);\nprintf(\"hh:mm = %02d:%02d\\n\", h, m); // hh:mm = 03:30\nreturn EXIT_SUCCESS;\n} </code></pre> </li> <li> <p>Escreva uma fun\u00e7\u00e3o mm que receba um vetor inteiro <code>v[0..n-1]</code> e os endere\u00e7os de duas vari\u00e1veis inteiras, digamos min e\u00a0max, e deposite nessas vari\u00e1veis o valor de um elemento m\u00ednimo e o valor de um elemento m\u00e1ximo do vetor.  Escreva tamb\u00e9m uma fun\u00e7\u00e3o main que use a fun\u00e7\u00e3o\u00a0mm.</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\nvoid mm(int *v, int n, int *minimo, int *maximo)\n{\nint min = v[0];\nint max = v[0];\nfor (int j = 0; j &lt; n; j++)\n{\nif (v[j] &gt; max)\nmax = v[j];\nif (v[j] &lt; min)\nmin = v[j];\n}\n*minimo = min;\n*maximo = max;\n}\nint main(void)\n{\nint v[] = {-10, 5, -20, 43, 217897, 123};\nint min, max;\nmm(v, 6, &amp;min, &amp;max);\nprintf(\"min: %d, max: %d\\n\", min, max); // min: -20, max: 217897\nreturn EXIT_SUCCESS;\n}\n</code></pre> </li> </ol>"},{"location":"resumos/ponteiros/#aritmetica-de-enderecos","title":"Aritm\u00e9tica de Endere\u00e7os","text":"<p>Os elementos de um vetor s\u00e3o armazenados em bytes consecutivos da mem\u00f3ria do computador, para facilitar o acesso, j\u00e1 que acessar uma determinada posi\u00e7\u00e3o de um vetor tem complexidade \\(O(1)\\). Se cada elemento de um vetor ocupa s bytes na mem\u00f3ria, a diferen\u00e7a entre os endere\u00e7os de dois elementos consecutivos \u00e9 de s bytes. Por exemplo, caso o v[0] esteja no endere\u00e7o 1000 de mem\u00f3ria, o v[10] estar\u00e1 na posi\u00e7\u00e3o 1040, j\u00e1 que cada posi\u00e7\u00e3o do vetor ocupa 4 bytes na mem\u00f3ria.</p> <p>Exemplo em c\u00f3digo:</p> <pre><code>    int tamanho = 10;\nint *v = malloc(tamanho * sizeof(int)); // Alocamos 10 posi\u00e7\u00f5es consecutivas na mem\u00f3ria para v. \nfor (int i = 0; i &lt; tamanho; i++)\n{\nif (i % 2 == 0)\n*(v + i) = 4; // O endere\u00e7o apontado por (v+i) recebe 4.\nelse\nv[i] = 7; // O endere\u00e7o apontado por (v+i) recebe 7.\n}\nprintf(\"[\");\nfor (int i = 0; i &lt; tamanho - 1; i++)\n{\nprintf(\"%d, \", v[i]);\n}\nprintf(\"%d]\\n\", v[tamanho - 1]); // [4, 7, 4, 7, 4, 7, 4, 7, 4, 7]\n</code></pre>"},{"location":"resumos/ponteiros/#referencias","title":"Refer\u00eancias","text":"<p>[1] Material sobre Ponteiros, do Professor Paulo Feofiloff, dispon\u00edvel no link.</p>"},{"location":"resumos/grafos/estrutura/","title":"Grafos","text":"<p>K\u00f6nigsberg (hoje Kaliningrado, R\u00fassia) tinha 7 pontes e acreditava-se que era poss\u00edvel passear por toda a cidade atravessando cada ponte exatamente uma vez.</p> <p> <p>Figura 1: Motiva\u00e7\u00e3o. Fonte: [1] </p> <p>Leonhard Euler, em 1736, modelou o problema como um grafo, provou que tal passeio n\u00e3o \u00e9 poss\u00edvel e fundou a teoria dos grafos.</p>"},{"location":"resumos/grafos/estrutura/#definicao","title":"Defini\u00e7\u00e3o","text":"<p>Um grafo \u00e9 um conjunto de objetos ligados, por arestas, entre si, chamados de v\u00e9rtices.</p> <p> <p></p> <p> Figura 2: Representa\u00e7\u00e3o de um Grafo. Fonte:[1] </p> <p></p> <p>Essa estrutura pode ser utilizada para a modelagem de problemas envolvendo redes sociais, mapas, p\u00e1ginas na internet, redes de computadores, circuitos eletr\u00f4nicos, dentre outros.</p> <p> Matematicamente, um grafo \\(G\\) \u00e9 um par ordenado \\(\\left (V,E\\right)\\) onde:</p> <ul> <li>V \u00e9 o conjunto dos v\u00e9rtices do grafo;</li> <li>Exemplo: $V={0, 1, 2, 3, 4, 5}</li> <li>E \u00e9 o conjunto de arestas do grafo;</li> <li>Representamos uma aresta ligando \\(u, v\\in V\\) como \\(\\{u,v\\}\\).</li> <li>Pra toda aresta \\(\\{u,v\\}\\) tem-se \\(u\\neq v\\);</li> <li>Existe no m\u00e1ximo uma aresta \\(\\{u, v\\} \\in E\\);</li> <li>\\(E=\\{\\{0,1\\}\\, \\{0, 4\\}, \\{5, 3\\}, \\{1, 2\\}, \\{2, 5\\}, \\{4, 5\\}, \\{3, 2\\}, \\{1, 4\\}\\}\\)</li> </ul> <p>Dizemos que os v\u00e9rtices 0 e 4 s\u00e3o adjacentes, e 0, 1 e 5 formam a vizinhan\u00e7a (conjunto de adjac\u00eancia) do v\u00e9rtice 4.</p>"},{"location":"resumos/grafos/estrutura/#matriz-de-adjacencias","title":"Matriz de Adjac\u00eancias","text":"<p>Um grafo pode ser representado por uma matriz de adjac\u00eancias.</p> <p>Se o grafo tem <code>n</code> v\u00e9rtices, teremos v\u00e9rtices numerados de <code>0</code> a <code>n-1</code> e a matriz com dimens\u00e3o \\(n \\times n\\).</p> <p>A matriz forma-se da seguinte maneira:</p> <ul> <li><code>adjacencia[u][v] = (u e v vizinhos)? 1 : 0</code>;</li> </ul> <p> <p></p> <p> Figura 3: Representa\u00e7\u00e3o do grafo em uma matriz de adjac\u00eancias. Fonte: [1] </p> <p></p> <p>A matriz de adjac\u00eancia \u00e9 sim\u00e9trica, pois \\(A_{i,j} = A_{j,i} \\forall i, j \\in [0, n-1]\\).</p> <p> Ressalvas ao utilizar matrizes: A representa\u00e7\u00e3o do grafo em matriz gera um desperd\u00edcio de mem\u00f3ria, pois bastaria guardar metade dos valores. H\u00e1 um alto consumo de mem\u00f3ria, a depender do tamanho do n. A matriz guarda as liga\u00e7\u00f5es e n\u00e3o liga\u00e7\u00f5es entre os v\u00e9rtices, mas poderia guardar apenas as liga\u00e7\u00f5es.</p>"},{"location":"resumos/grafos/estrutura/#implementacao","title":"Implementa\u00e7\u00e3o","text":"<p>A estrutura do grafo com matriz de adjac\u00eancias <code>adj</code> e <code>n</code> v\u00e9rtices \u00e9 dada por:</p> grafo.c<pre><code>typedef struct\n{\nint **adj;\nint n;\n} Grafo;\ntypedef Grafo *p_grafo;\np_grafo criar_grafo(int n);\nvoid destruir_grafo(p_grafo g);\nvoid insere_aresta(p_grafo g, int u, int v);\nvoid remove_aresta(p_grafo g, int u, int v);\nint tem_aresta(p_grafo g, int u, int v);\nvoid imprime_arestas(p_grafo g);\nint grau(p_grafo, int a);\nint mais_popular(p_grafo g);\nvoid imprime_recomendacoes(p_grafo g, int u);\n</code></pre>"},{"location":"resumos/grafos/estrutura/#inicializacao-e-destruicao","title":"Inicializa\u00e7\u00e3o e destrui\u00e7\u00e3o","text":"criar.c<pre><code>p_grafo criar_grafo(int n)\n{\np_grafo p = malloc(sizeof(Grafo));\np-&gt;n = n;\np-&gt;adj = malloc(n * sizeof(int *));\nfor (int i = 0; i &lt; n; i++)\np-&gt;adj[i] = malloc(n * sizeof(int));\nfor (int i = 0; i &lt; n; i++)\nfor (int j = 0; j &lt; n; j++)\np-&gt;adj[i][j] = 0;\nreturn p;\n}\nvoid destruir_grafo(p_grafo g)\n{\nfor (int i = 0; i &lt; g-&gt;n; i++)\nfree(g-&gt;adj[i]);\nfree(g-&gt;adj);\nfree(g);\n}\n</code></pre>"},{"location":"resumos/grafos/estrutura/#manipulando-arestas","title":"Manipulando arestas","text":"manipulando_arestas.c<pre><code>void insere_aresta(p_grafo g, int u, int v)\n{\nif (u &lt; g-&gt;n &amp;&amp; v &lt; g-&gt;n)\n{\ng-&gt;adj[u][v] = 1;\ng-&gt;adj[v][u] = 1;\n}\n}\nvoid remove_aresta(p_grafo g, int u, int v)\n{\nif (u &lt; g-&gt;n &amp;&amp; v &lt; g-&gt;n)\n{\ng-&gt;adj[u][v] = 0;\ng-&gt;adj[v][u] = 0;\n}\n}\nint tem_aresta(p_grafo g, int u, int v)\n{\nif (u &lt; g-&gt;n &amp;&amp; v &lt; g-&gt;n)\nreturn g-&gt;adj[u][v];\nreturn -1;\n}\n</code></pre>"},{"location":"resumos/grafos/estrutura/#lendo-e-imprimindo-um-grafo","title":"Lendo e imprimindo um Grafo","text":"leitura.c<pre><code>p_grafo le_grafo()\n{\np_grafo g;\nint tam, qtd, u, v;\nscanf(\"%d %d\", &amp;tam, &amp;qtd);\ng = criar_grafo(tam);\nfor (int i = 0; i &lt; qtd; i++)\n{\nscanf(\"%d %d\", &amp;u, &amp;v);\ninsere_aresta(g, u, v);\n}\nreturn g;\n}\nvoid imprime_arestas(p_grafo g)\n{\nint u, v;\nfor (u = 0; u &lt; g-&gt;n; u++)\nfor (v = u + 1; v &lt; g-&gt;n; v++)\nif (g-&gt;adj[u][v])\nprintf(\"{%d, %d}\\n\", u, v);\n}\n</code></pre>"},{"location":"resumos/grafos/estrutura/#grau","title":"Grau","text":"<p>O grau de um v\u00e9rtice \u00e9 a quantidade de arestas que saem dele.</p> <p>Para calcular o grau de um v\u00e9rtice, basta percorrer a quantidade de <code>1</code> na linha (ou coluna) correspondente ao v\u00e9rtice.</p> grau.c<pre><code>int grau(p_grafo g, int u)\n{\nint grau = 0;\nfor (int i = 0; i &lt; g-&gt;n; i++)\ngrau += g-&gt;adj[u][i];\nreturn grau;\n}\nint mais_popular(p_grafo g)\n{\nint mais_popular = 0;\nint maior_grau = grau(g, mais_popular);\nint grau_c;\nfor (int i = 0; i &lt; g-&gt;n; i++)\n{\ngrau_c = grau(g, i);\nif (maior_grau &lt; grau_c)\n{\nmais_popular = i;\nmaior_grau = grau_c;\n}\n}\nreturn mais_popular;\n}\n</code></pre>"},{"location":"resumos/grafos/estrutura/#recomendacoes","title":"Recomenda\u00e7\u00f5es","text":"<p>No contexto das redes sociais, \u00e9 comum que sejam recomendados amigos para os membros da rede. Por exemplo, podemos sugerir novos amigos para Ana (Figura 2), baseando-nos nas conex\u00f5es que ela j\u00e1 possui.</p> <p> <p>Figura 2: Recomenda\u00e7\u00e3o de amigos. Fonte: [1] </p> <p>Essa recomenda\u00e7\u00e3o pode ser feita com o algoritmo a seguir.</p> recomendacoes.c<pre><code>void imprime_recomendacoes(p_grafo g, int u)\n{\nfor (int i = 0; i &lt; g-&gt;n; i++)\nif (tem_aresta(g, u, i))\nfor (int j = 0; j &lt; g-&gt;n; j++)\nif (tem_aresta(g, i, j) &amp;&amp; j != u &amp;&amp; !tem_aresta(g, u, j))\nprintf(\"%d \", j);\n}\n</code></pre>"},{"location":"resumos/grafos/estrutura/#grafos-dirigidos","title":"Grafos Dirigidos","text":"<p>Um grafo dirigido (d\u00edgrafo) possui um conjunto de v\u00e9rtices conectados por arcos, que s\u00e3o arestas dirigidas, i. e., arestas que indicam in\u00edcio e fim.</p> <p> <p>Figura 4: Grafo Dirigidos. Fonte: [1] </p> <p>Matematicamente, um d\u00edgrafo \\(G\\) \u00e9 um par \\((V,A)\\) formado pelos conjuntos de v\u00e9rtices \\(V\\) e arestas \\(A\\).</p> <ul> <li>Representamos um arco ligando \\(u,v\\in\\ V\\) como \\((u,v)\\), onde \\(u\\) \u00e9 a cauda do arco e \\(v\\) a cabe\u00e7a.</li> <li>Podemos ter la\u00e7os da forma \\((u,u)\\)</li> <li>Existe no m\u00e1ximo um arco \\((u,v)\\) em \\(A\\).</li> </ul> <p> Um grafo pode ser visto como um d\u00edgrafo se considerarmos cada aresta como  dois arcos. A implementa\u00e7\u00e3o por matriz de adjac\u00eancias j\u00e1 considera os dois arcos, ent\u00e3o nesse caso pode ocorrer: <code>adj[u][v] != adj[v][u]</code>, j\u00e1 que <code>adj[u][v]</code> indica um arco de \\(u\\) para \\(v\\).</p>"},{"location":"resumos/grafos/estrutura/#numero-de-arestas","title":"N\u00famero de Arestas","text":"<p> <p>Figura 5: Grafo com a quantidade m\u00e1xima de arestas. Fonte: [1] </p> <p>Um grafo com \\(n\\) v\u00e9rtices pode ter no m\u00e1ximo \\(\\binom{n}{2} = \\frac{n(n-1)}{2} = O(n^2)\\) arestas. E dizemos que um grafo \u00e9 esparso quando ele possui bem menos (em outra ordem de grandeza) do que essa quantidade de arestas.</p> <p>Exemplos de grafos esparsos:</p> <ul> <li>Grafos cujos v\u00e9rtices tem o mesmo grau \\(d\\) constante, possuem \\(\\frac{nd}{2} = O(n)\\) arestas.</li> <li>Grafos com \\(O(n\\ log\\ n)\\) arestas.</li> </ul>"},{"location":"resumos/grafos/estrutura/#listas-de-adjacencias","title":"Listas de Adjac\u00eancias","text":"<p> <p>Figura 6: Representa\u00e7\u00e3o do grafo por lista de adjac\u00eancias. Fonte: [1] </p> header.c<pre><code>typedef struct No\n{\nint v;\nstruct No *prox;\n} No;\ntypedef No *p_no;\ntypedef struct\n{\np_no *adjacencia;\nint n;\n} Grafo;\ntypedef Grafo *p_grafo;\np_grafo criar_grafo(int n);\nvoid destroi_grafo(p_grafo g);\nvoid insere_aresta(p_grafo g, int u, int v);\nvoid remove_aresta(p_grafo g, int u, int v);\nint tem_aresta(p_grafo g, int u, int v);\nvoid imprime_arestas(p_grafo g);\n</code></pre>"},{"location":"resumos/grafos/estrutura/#inicializacao","title":"Inicializa\u00e7\u00e3o","text":"inicializacao.c<pre><code>p_grafo criar_grafo(int n)\n{\nint i;\np_grafo g = malloc(sizeof(Grafo));\ng-&gt;n = n;\ng-&gt;adjacencia = malloc(n * sizeof(p_no));\nfor (i = 0; i &lt; n; i++)\ng-&gt;adjacencia[i] = NULL;\nreturn g;\n}\nvoid libera_lista(p_no lista)\n{\nif (lista != NULL)\n{\nlibera_lista(lista-&gt;prox);\nfree(lista);\n}\n}\nvoid destroi_grafo(p_grafo g)\n{\nint i;\nfor (i = 0; i &lt; g-&gt;n; i++)\nlibera_lista(g-&gt;adjacencia[i]);\nfree(g-&gt;adjacencia);\nfree(g);\n}\n</code></pre>"},{"location":"resumos/grafos/estrutura/#manipulacao-de-arestas","title":"Manipula\u00e7\u00e3o de Arestas","text":"arestas.c<pre><code>p_no insere_na_lista(p_no lista, int v)\n{\np_no novo = malloc(sizeof(No));\nnovo-&gt;v = v;\nnovo-&gt;prox = lista;\nreturn novo;\n}\nvoid insere_aresta(p_grafo g, int u, int v)\n{\ng-&gt;adjacencia[v] = insere_na_lista(g-&gt;adjacencia[v], u);\ng-&gt;adjacencia[u] = insere_na_lista(g-&gt;adjacencia[u], v);\n}\np_no remove_da_lista(p_no lista, int v)\n{\np_no proximo;\nif (lista == NULL)\nreturn NULL;\nelse if (lista-&gt;v == v)\n{\nproximo = lista-&gt;prox;\nfree(lista);\nreturn proximo;\n}\nelse\n{\nlista-&gt;prox = remove_da_lista(lista-&gt;prox, v);\nreturn lista;\n}\n}\nvoid remove_aresta(p_grafo g, int u, int v)\n{\ng-&gt;adjacencia[u] = remove_da_lista(g-&gt;adjacencia[u], v);\ng-&gt;adjacencia[v] = remove_da_lista(g-&gt;adjacencia[v], u);\n}\nint tem_aresta(p_grafo g, int u, int v)\n{\np_no t;\nfor (t = g-&gt;adjacencia[u]; t != NULL; t = t-&gt;prox)\nif (t-&gt;v == v)\nreturn 1;\nreturn 0;\n}\nvoid imprime_arestas(p_grafo g)\n{\nint u;\np_no t;\nfor (u = 0; u &lt; g-&gt;n; u++)\nfor (t = g-&gt;adjacencia[u]; t != NULL; t = t-&gt;prox)\nprintf(\"{%d,%d}\\n\", u, t-&gt;v);\n}\n</code></pre>"},{"location":"resumos/grafos/estrutura/#comparacao-listas-vs-matrizes","title":"Compara\u00e7\u00e3o Listas vs Matrizes","text":"<p>Espa\u00e7o necess\u00e1rio para o armazenamento:</p> <ul> <li>Matriz: \\(O(n^2)\\)</li> <li>Listas: \\(O(n + |E|)\\)</li> </ul> <p> \\(n=|V|\\), onde V \u00e9 o conjunto das arestas (ou arcos).</p> <p>Comparativo de tempo:  Opera\u00e7\u00e3o Matriz Listas Inserir \\(O(1)\\) \\(O(1)\\) Remover \\(O(1)\\) \\(O(d(v))\\) Aresta Existe? \\(O(1)\\) \\(O(d(v))\\) Percorrer Vizinhan\u00e7a \\(O(n)\\) \\(O(d(v))\\) <p></p>"},{"location":"resumos/grafos/estrutura/#o-problema-das-pontes-de-konigsberg","title":"O problema das Pontes de K\u00f6nigsberg","text":"<p> <p>Figura 7: Grafos para o problema das Pontes. Fonte: [1] </p> <p>A estrutura da Figura 1 \u00e9 chamada de multigrafo, nela \u00e9 poss\u00edvel ter arestas paralelas (ou m\u00faltiplas), existe um multiconjunto de arestas e pode ser representada por listas de adjac\u00eancia.</p>"},{"location":"resumos/grafos/estrutura/#referencias","title":"Refer\u00eancias","text":"<p>[1] Grafos (Estrutura) - Notas de aula do professor Rafael C. S. Schouery, dispon\u00edveis no link.</p>"},{"location":"resumos/grafos/percursos/","title":"Percursos","text":""},{"location":"resumos/grafos/percursos/#caminho","title":"Caminho","text":"<p>Um caminho de <code>s</code> para <code>t</code> em um grafo \u00e9:</p> <ul> <li>Uma sequ\u00eancia sem repeti\u00e7\u00e3o de v\u00e9rtices vizinhos</li> <li>Come\u00e7ando em <code>s</code> e terminando em <code>t</code></li> </ul> <p>Formalmente, um caminho de <code>s</code> para <code>t</code> em um grafo \u00e9:</p> <ul> <li>Uma sequ\u00eancia de v\u00e9rtices \\(v_0, v_1, ..., v_k\\) onde \\(v_0=s\\) e \\(v_k=t\\)</li> <li>\\(\\{v_i, v_{i+1}\\}\\) \u00e9 uma aresta \\(\\forall 0\\leq i \\leq k-1\\)</li> <li>\\(v_i\\neq v_j \\forall 0 \\leq i &lt; j \\leq k\\)</li> </ul> <p>\\(k\\) \u00e9 o comprimento do caminho, a quantidade de v\u00e9rtices do caminho - 1.</p>"},{"location":"resumos/grafos/percursos/#componentes-conexas","title":"Componentes Conexas","text":"<p>Um grafo pode ser dividido em v\u00e1rias \"partes\", chamadas de componentes conexas.</p> <p> <p>Figura 1: Componentes Conexas. Fonte: [1] </p> <p>Um par de v\u00e9rtices est\u00e1 na mesma componente se, e somente se, existe caminho entre eles. N\u00e3o h\u00e1 caminho entre v\u00e9rtices de componentes distintas.</p> <p>Um grafo conexo tem apenas uma componente conexa.</p>"}]}